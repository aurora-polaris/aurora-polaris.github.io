<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  

  
  
  
  
  
  
  <title>耿珊珊的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="耿珊珊的个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="耿珊珊的个人博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="耿珊珊的个人博客">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="耿珊珊的个人博客" rel="home">耿珊珊的个人博客</a>
      </h1>
      
        <script type="text/javascript" src="http://api.hitokoto.us/rand?encode=js&charset=utf-8"></script>
        <h2 class="site-description"><script>hitokoto();</script></h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-canvas" class="post-canvas post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2018/06/19/canvas/">blog</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2018/06/19/canvas/" data-id="cjimfl4xw0000ogwsj6zhmii1" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="要不要一起了解一下canvas"><a href="#要不要一起了解一下canvas" class="headerlink" title="要不要一起了解一下canvas"></a><strong>要不要一起了解一下canvas</strong></h1><h3 id="博客试水文章第一篇-—-canvas基础"><a href="#博客试水文章第一篇-—-canvas基础" class="headerlink" title="博客试水文章第一篇 — canvas基础"></a>博客试水文章第一篇 — canvas基础</h3><h2 id="第一话-与canvas的初次邂逅"><a href="#第一话-与canvas的初次邂逅" class="headerlink" title="第一话 与canvas的初次邂逅"></a>第一话 与canvas的初次邂逅</h2><blockquote>
<p>姓名：canvas<br><br>自我介绍：一个默认宽为300，高150的空白画布，可以使用脚本来绘制图形的html元素，可以绘制图表、制作图片构图或者制作简单的动画<br><br>哦，对了，他说他只是一个容器，本身没有绘制能力，所以他在等一个意中人拿到一个画布使之具有绘制各种弄图形的能力，他的意中人应该可以做到以下几点：<br></p>
</blockquote>
<ol>
<li><strong>有一个舒适的地方（页面）</strong>:一般我们最常用html文件<br></li>
<li><strong>里面要有标签</strong> :作为h5新标签，不太支持较老版本的浏览器，因此稍稍判断以下还是可以的，或者说如果你用的浏览器版本比较新 ，那可以不用写‘你的浏览器不支持canvas’这句话了，同时我们在标签上规定id、宽高，这里的宽高如果拿到外面去设置就会导致canvas变形，所以乖乖的这里设，至于其他样式设置就拿到外面去吧<br><br><code>&lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;500&quot;&gt;你的浏览器不支持canvas&lt;/canvas&gt;</code>   </li>
<li><strong>获取到这个画布</strong> :每个canvas节点都有一个对应的context对象（上下文对象），Canvas API定义在这个context对象上面，所以需要获取这个对象，方法是使用<strong><em>getContext</em></strong>方法。即Canvas.getContext(contextID)，参数 <strong><em>contextID</em></strong> 指定了您想要在画布上绘制的类型。当前唯一的合法值是 “2d”，它指定了二维绘图，并且导致这个方法返回一个环境对象，该对象导出一个二维绘图 API。在未来，如果 canvas 标签扩展到支持 3D 绘图，getContext() 方法可能允许传递一个 “3d” 字符串参数。<br></li>
</ol>
<pre><code>var canvas=document.getElementById(&apos;canvas&apos;) 
//获得画布
var context=canvas.getContext(&apos;2d&apos;)
</code></pre><hr>
<h2 id="第二话-他的意中人"><a href="#第二话-他的意中人" class="headerlink" title="第二话  他的意中人"></a>第二话  他的意中人</h2><ul>
<li>跟矩形有关的那点事</li>
</ul>
<blockquote>
<p>在此之前，我们先做一下准备工作：<br></p>
<ol>
<li><strong>fillReact</strong>(坐标x，坐标y，宽，高):一般用于绘制实心的矩形，与<strong>fillStyle()</strong> 填充颜色搭配使用；<br><br>2.<strong>strokeReact</strong>(坐标x，坐标y，宽，高) : 一般绘制空心的矩形，与<strong>strokeStyle()</strong> 设置边框颜色搭配使用；<br><br>3.<strong>context.benginPath():</strong> 开始路径；<br><br>4.<strong>context.closePath()</strong> : 结束路径，值得注意的是<blockquote>
<p>1、系统默认在绘制第一个路径的开始点beginPath <br><br>2、如果画完前面的路径没有重新指定beginPath，那么画第其他路径的时候会将前面最近指定的beginPath后的全部路径重新绘制<br>3、每次调用context.fill（）的时候会自动把当次绘制的路径的开始点和结束点相连，接着填充封闭的部分，这时也就不用调用closePath()了，但是调用strock()不会自动闭合<br></p>
</blockquote>
</li>
</ol>
</blockquote>
<pre><code> var canvas=document.getElementById(&apos;canvas&apos;)
//获得画布
var context=canvas.getContext(&apos;2d&apos;)
context.beginPath();               // 开始路径
context.fillStyle=&apos;yellow&apos;         // 设置要填充的颜色
context.fillRect(100,150,100,100) 
context.fill()                     // 全部填充
</code></pre><p>这样做，我们就可以得到下面这个图<br><br><img src="https://i.imgur.com/I7DpFNM.jpg" alt=""></p>
<p>再来个空心的像这样的<br><br><img src="https://i.imgur.com/xxPO2Lj.jpg" alt=""></p>
<pre><code>context.beginPath()
context.strokeStyle=&quot;red&quot;
context.strokeRect(150,150,100,100)
context.fill()
</code></pre><p>什么？想要个橡皮擦？没问题，满足你<br><br><code>context.clearRect(x,y,width,height)仅支持矩形</code>  <br><br>    context.clearRect(30,30,50,50) <br></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://i.imgur.com/016QDJX.jpg" alt=""></h2><p>矩形的故事先说到这里，下面我们来说说圆形那个家伙<br></p>
<ul>
<li>一个球的故事</li>
</ul>
<blockquote>
<p>跟矩形的套路差不多 ，我们常用来画圆的是<strong>arc</strong> ，<br><br> <strong>context.arc(x, y, radius, starAngle,endAngle, anticlockwise)</strong>  坐标位置不用介绍了，后面就是半径，开始弧度，结束弧度，顺逆时针//绘制圆形</p>
</blockquote>
<pre><code>context.beginPath()
context.arc(250,250,20,0,Math.PI*2,true)
context.closePath()
context.fillStyle=&apos;rgba(0,255,0,0.25)&apos;
context.fill()
</code></pre><p><img src="https://i.imgur.com/yNWlQyG.jpg" alt=""></p>
<p>然后差不多就是这个样子了</p>
<hr>
<h1 id="第三话-贝塞尔的约会"><a href="#第三话-贝塞尔的约会" class="headerlink" title="第三话  贝塞尔的约会"></a>第三话  贝塞尔的约会</h1><blockquote>
<p>在说约会的故事前，先来认识一下牵线人<br><br>线段 <strong>context.moveTo(x,y)  context.lineTo(x,y)</strong>  <br></p>
<blockquote>
<p><strong>moveTo(x,y)</strong> 移动到某一点，但是它只是代表的作画的起点<br><br><strong>lineTo(x,y)</strong> 与上面的对应，代表作画的终点，每次画线都从moveTo的点到lineTo的点，如果没有moveTo那么第一次lineTo的效果和moveTo一样，每次lineTo后如果没有moveTo，那么下次lineTo的开始点为前一次lineTo的结束点<br></p>
</blockquote>
<p>Bézier curve(贝塞尔曲线)是应用于二维图形应用程序的数学曲线。 曲线定义：起始点、终止点、控制点。通过调整控制点，贝塞尔曲线的形状会发生变化。 1962年，法国数学家Pierre Bézier第一个研究了这种矢量绘制曲线的方法，并给出了详细的计算公式，因此按照这样的公式绘制出来的曲线就用他的姓氏来命名，称为贝塞尔曲线。来见识一下贝塞尔如何？下面是五阶贝塞尔曲线的绘制过程<br><br><img src="https://i.imgur.com/50IpUOi.gif" alt=""></p>
</blockquote>
<blockquote>
<p>如果觉得太复杂，那我们先来看二阶的<br><br><img src="https://i.imgur.com/2AjdHHO.gif" alt=""><br>是不是好很多绘制贝塞尔曲线（贝济埃、bezier）</p>
<blockquote>
<p><strong>context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y) </strong>先来说说个个参数都代表什么 <br><br>   cp1x:第一个控制点x坐标 <br><br>   cp1y:第一个控制点y坐标 <br><br>   cp2x:第二个控制点x坐标 <br><br>   cp2y:第二个控制点y坐标  <br><br>   x:终点x坐标 <br><br>   y:终点y坐标 <br><br>如果你想要了解他的算法，可以参考一下这个<br><br><a href="http://www.cnblogs.com/wxydigua/p/4204254.html" target="_blank" rel="noopener">http://www.cnblogs.com/wxydigua/p/4204254.html</a><br><a href="http://www.cnblogs.com/regina1123/p/6256375.html" target="_blank" rel="noopener">http://www.cnblogs.com/regina1123/p/6256375.html</a></p>
</blockquote>
</blockquote>
<p><img src="https://i.imgur.com/RJFF7T5.jpg" alt=""></p>
<pre><code>ctx.beginPath();
ctx.moveTo(75,25);  // 开个头
ctx.quadraticCurveTo(25,25,25,62.5);
ctx.quadraticCurveTo(25,100,50,100);
ctx.quadraticCurveTo(50,120,30,125);
ctx.quadraticCurveTo(60,120,65,100);
ctx.quadraticCurveTo(125,100,125,62.5);
ctx.quadraticCurveTo(125,25,75,25);
ctx.stroke();
</code></pre><p>结果如下<br><br><img src="https://i.imgur.com/u1LYJxv.jpg" alt=""> <br><br>还可以吧，没那么丑，至于那个控制点，个人理解为以moveTo为中心，向前向后画曲线，然后就这样了，当然如果想要画更复杂的图，可以在好好研究一下,还有一点<strong>值得注意</strong>，精确画图时，我们要考虑一下线条的像素会不会对你的图有影响？比如说，我们想要一个1像素的，但是结果却不太像1像素的<br><br><img src="https://i.imgur.com/AYKAG1p.jpg" alt=""> <br><br>这是因为计算机不允许出现小于1px的图形，所以他做了一个折中的事：把这两个像素都绘制了。所以，如此一来，本来1px的线条，就成了看起来2px宽的线。也就是说这个1像素为了能生存下去，就向左向右跨了0.5像素，也就成了2像素<br><br><img src="https://i.imgur.com/IN9Pe6r.jpg" alt=""> <br><br>为了解决这个问题，聪明的人们还是想到了办法的，那就是给需要的地方加上0.5像素，虽然有点麻烦，但是亲测有效</p>
<hr>
<h1 id="第四话-初识文（文字）阴（阴影）渐（渐变）"><a href="#第四话-初识文（文字）阴（阴影）渐（渐变）" class="headerlink" title="第四话  初识文（文字）阴（阴影）渐（渐变）"></a>第四话  初识文（文字）阴（阴影）渐（渐变）</h1><ul>
<li>我是文字啊<br><blockquote>
<p>fillText(text, x, y [, maxWidth])<br>在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的. 当然如果绘制一个空心的也可以，那就这样strokeText(text, x, y);ctx.font = “20px Arial”;</p>
</blockquote>
</li>
</ul>
<pre><code>ctx.textBaseline = &quot;hanging&quot;;
ctx.strokeText(&quot;Hello &quot;, 50, 50);
</code></pre><p><img src="https://i.imgur.com/GOcAPID.jpg" alt=""> <br></p>
<ul>
<li>嗯，我是阴影 <blockquote>
<p>context.shadowOffsetX :阴影的横向位移量（默认值为0）<br>context.shadowOffsetY :阴影的纵向位移量（默认值为0）<br>context.shadowColor :阴影的颜色<br>context.shadowBlur :阴影的模糊范围（值越大越模糊）</p>
</blockquote>
</li>
</ul>
<p><img src="https://i.imgur.com/1V0jq1s.jpg" alt=""></p>
<pre><code>ctx.shadowOffsetX = 2; //X轴阴影距离，负上，正下
ctx.shadowOffsetY = 2; //Y轴阴影距离，负左，正右
ctx.shadowBlur = 2; //阴影的模糊程度
ctx.shadowColor = &quot;rgba(0, 0, 0, 0.5)&quot;; //阴影颜色
ctx.font = &quot;30px Times New Roman&quot;; //设置字体和字体大小 
ctx.fillStyle = &quot;Black&quot;; 
ctx.fillText(&quot;Sample String&quot;, 15, 30); //实体文字
ctx.strokeStyle = &apos;red&apos;; 
ctx.strokeText(&apos;Hello world&apos;, 15, 100); //边框文字
</code></pre><ul>
<li>我，我是渐变…… <br></li>
</ul>
<blockquote>
<p>线性渐变 <strong>createLinearGradient(xStart,yStart,xEnd,yEnd)</strong><br><br>线性渐变颜色addColorStop(offset,color)<br><br>xstart:渐变开始点x坐标 <br><br>ystart:渐变开始点y坐标<br><br>xEnd:渐变结束点x坐标<br><br>yEnd:渐变结束点y坐标<br><br>offset:设定的颜色离渐变结束点的偏移量(0~1)<br><br>color:绘制时要使用的颜色<br></p>
</blockquote>
<p><img src="https://i.imgur.com/SC0fAW4.jpg" alt=""><br></p>
<pre><code>let can=document.getElementById(&apos;Canvas&apos;)
let ctx=Canvas.getContext(&apos;2d&apos;)
let bg = ctx.createLinearGradient(0, 0, 0, 200); 
bg.addColorStop(0, &apos;black&apos;); // 开始颜色
bg.addColorStop(0.6, &apos;#fff’);  //结束颜色
ctx.fillStyle = bg;
ctx.fillRect(10, 10, 100, 100);
</code></pre><blockquote>
<p>径向渐变（发散）<strong>context.createRadialGradient(xStart,yStart,radiusStart,xEnd,yEnd,radiusEnd)</strong><br><br>径向渐变（发散）颜色<strong>rg.addColorStop(offset,color) </strong> <br><br>xStart:发散开始圆心x坐标<br><br>yStart:发散开始圆心y坐标<br><br>radiusStart:发散开始圆的半径<br><br>xEnd:发散结束圆心的x坐标<br><br>yEnd:发散结束圆心的y坐标<br><br>radiusEnd:发散结束圆的半径<br><br>offset:设定的颜色离渐变结束点的偏移量(0~1) <br><br>color:绘制时要使用的颜色<br></p>
</blockquote>
<p><img src="https://i.imgur.com/oBvDDsm.jpg" alt=""><br></p>
<pre><code>var bg1 = ctx.createRadialGradient(100, 100, 0, 100, 100, 50);
bg1.addColorStop(0, &apos;#FF5F98&apos;);
bg1.addColorStop(0.75, &apos;#FF0188&apos;);
bg1.addColorStop(1, &apos;rgba(255,1,136,0)&apos;);
ctx.fillStyle = bg1; 
ctx.fillRect(0,0,150,150);
</code></pre><hr>
<h1 id="第五话-千变万化"><a href="#第五话-千变万化" class="headerlink" title="第五话   千变万化"></a>第五话   千变万化</h1><blockquote>
<p>这里先了解一下状态：对于canvas 的状态就是当前画面应用的所有样式和变形的一个快照，操作状态有两个方法：save() 和 restore （），前者是用来保存当前状态，后者用来恢复刚才保存的状态，他们都可以多次调用，举个例子</p>
</blockquote>
<pre><code>ctx.fillStyle = &apos;black&apos;; 
ctx.fillRect(20, 20, 150, 150); 
ctx.save(); //保存当前状态 
ctx.fillStyle= &apos;#fff’; 
ctx.fillRect(45, 45, 100, 100); 
ctx.restore(); //恢复到刚才保存的状态 
ctx.fillRect(70, 70, 50, 50);
</code></pre><p>然后就这样了<br><img src="https://i.imgur.com/lZICR8n.jpg" alt=""><br></p>
<blockquote>
<p>位移了解一下？ctx.translate(x, y); //更改canvas的原点</p>
</blockquote>
<pre><code>for(var i = 1; i&lt; 4; i++) { 
ctx.save(); 
//使用save方法保存状态，让每次位移时都针对（0，0）移动。 
ctx.translate(100*i, 0); 
ctx.fillRect(0, 50, 50, 50);
ctx.restore(); 
}
</code></pre><p><img src="https://i.imgur.com/UG6QkW1.jpg" alt=""><br></p>
<blockquote>
<p>缩放也了解一下吧 ctx.scale(x, y); //基于原点缩放，x、y是两个轴的缩放倍数</p>
</blockquote>
<pre><code>var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d’); 
ctx.fillStyle = &apos;red’; 
ctx.scale(0.8, 1.2); 
ctx.beginPath(); 
ctx.arc(75, 75, 60, 0, Math.PI * 2); ctx.fill();
</code></pre><p><img src="https://i.imgur.com/vu4XTde.jpg" alt=""><br></p>
<h1 id="第六话-有情人终成眷属"><a href="#第六话-有情人终成眷属" class="headerlink" title="第六话 有情人终成眷属"></a>第六话 有情人终成眷属</h1><p><img src="https://i.imgur.com/eAHKlLh.gif" alt=""><br><br>我们来简单结合一下图形做一个好看的效果，像这样的怎么样是不是还可以，那就上代码<br><img src="https://i.imgur.com/8JrUeRm.jpg" alt=""><br></p>
<pre><code>let can=document.getElementById(&apos;can&apos;)
let context=can.getContext(&apos;2d&apos;)
//绘制颜色板
for(let i=0;i&lt;6;i++){
   for(let j=0;j&lt;6;j++){
    context.fillStyle=&apos;rgb(&apos;+Math.floor(255-42.5*i)+&apos;,&apos;+Math.floor(255-42.5*j)+&apos;,0)&apos;
    context.fillRect(i*25,j*25,25,25)
    }
}
//绘制圆形
for(var i=0;i&lt;10;i++){
   for(var j=0;j&lt;10;j++){
    context.strokeStyle=&apos;rgb(0,&apos;+Math.floor(255-42.5*i)+&apos;,&apos;+Math.floor(255-42.5*j)+&apos;)&apos;
    context.beginPath()
    context.arc(12.5+j*25,180+i*25,10,0,Math.PI*2,true)
    context.stroke()
  }
}
</code></pre><p>最后经过不懈的努力，他们就变成了这个样纸，代码找不到了，反正就是拼在一起就好了^_^ <br><br><img src="https://i.imgur.com/lDQwssl.jpg" alt=""><br>嗯，总结到此先告一段落，希望对你有帮助……</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2018/06/19/canvas/">
    <time datetime="2018-06-19T01:19:07.000Z" class="entry-date">
        2018-06-19
    </time>
</a>
    
    
    </footer>
</article>






  
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2018/06/19/canvas/">blog</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2018 John Doe
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>